<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Monster Waves</title>
<style>
body {
    text-align: center;
    background: linear-gradient(135deg,#0a0a0a,#3b3b3b);
    color: #fff;
    font-family: Arial, sans-serif;
    margin:0; padding:0;
}

canvas {
    background-color: #222;
    border-radius: 15px;
    border: 3px solid #fff;
    display: block;
    margin: 20px auto;
    box-shadow: 0 0 20px rgba(0,0,0,0.7);
}

#hud {
    margin-top: 10px;
    font-size: 20px;
    display: flex;
    justify-content: center;
    gap: 30px;
    font-weight: bold;
    align-items: center;
}

#healthBar {
    width: 200px;
    height: 20px;
    background: #444;
    border-radius: 10px;
    overflow: hidden;
}

#healthInner {
    height: 100%;
    background: linear-gradient(to right, #0f0,#0c0);
    width: 100%;
}
</style>
</head>
<body>
<h1>Monster Waves</h1>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<div id="hud">
    <span id="score">Score: 0</span>
    <span id="time">Tid: 0s</span>
    <span id="wave">Wave: 1</span>
    <div id="healthBar"><div id="healthInner"></div></div>
</div>

<script>
// Canvas
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Spelare
const player = {
    x: canvas.width/2,
    y: canvas.height/2,
    radius: 20,
    color: 'green',
    speed: 5,
    health: 100,
    maxHealth: 100,
    bullets: [],
    fireRate: 500,
    lastShot: 0
};

// Spelvariabler
let keys = {};
let score = 0;
let elapsedTime = 0;
let enemies = [];
let powerups = [];
let wave = 1;
let lastEnemySpawn = 0;
let lastPowerupSpawn = 0;
let gameOver = false;

// Base64-ljud (placeholder)
// Du kan byta till riktiga mp3 i mappen
const shootSound = new Audio('data:audio/mp3;base64,//uQxAAA...');
const hitSound = new Audio('data:audio/mp3;base64,//uQxAAA...');
const powerupSound = new Audio('data:audio/mp3;base64,//uQxAAA...');
const gameOverSound = new Audio('data:audio/mp3;base64,//uQxAAA...');

document.addEventListener('keydown', e=>keys[e.key]=true);
document.addEventListener('keyup', e=>keys[e.key]=false);
canvas.addEventListener('click', shootBullet);

function shootBullet(e){
    const now = Date.now();
    if(now - player.lastShot < player.fireRate) return;
    player.lastShot = now;

    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const angle = Math.atan2(mouseY - player.y, mouseX - player.x);
    player.bullets.push({x: player.x, y: player.y, angle, speed: 10});
    shootSound.currentTime=0; shootSound.play();
}

// Spawn fiender (svårare per wave)
function spawnEnemy(){
    const side = Math.random()<0.5?'left':'right';
    const x = side==='left'?0:canvas.width;
    const y = Math.random()*canvas.height;
    const size = Math.random()*15 + 15;
    const speed = 2 + Math.random()*2 + wave*0.3; // snabbare varje wave
    const colors = ['red','orange','purple','blue'];
    const color = colors[Math.floor(Math.random()*colors.length)];
    enemies.push({x,y,radius:size,speed,color});
}

// Spawn powerup
function spawnPowerup(){
    const x = Math.random()*(canvas.width-20)+10;
    const y = Math.random()*(canvas.height-20)+10;
    const type = Math.random()<0.33?'heal':(Math.random()<0.5?'fast':'speed');
    powerups.push({x,y,radius:10,type});
}

// Reset game
function resetGame(){
    player.health = player.maxHealth;
    player.x = canvas.width/2;
    player.y = canvas.height/2;
    enemies = [];
    powerups = [];
    score = 0;
    elapsedTime = 0;
    wave = 1;
    gameOver = false;
    gameOverSound.play();
}

// Update
function update(deltaTime){
    if(gameOver) return;
    elapsedTime += deltaTime/1000;

    // Rörelse
    let currentSpeed = player.speed;
    if(player.speedBoost) currentSpeed *= 1.5;
    if(keys['w']||keys['ArrowUp']) player.y -= currentSpeed;
    if(keys['s']||keys['ArrowDown']) player.y += currentSpeed;
    if(keys['a']||keys['ArrowLeft']) player.x -= currentSpeed;
    if(keys['d']||keys['ArrowRight']) player.x += currentSpeed;

    player.x = Math.max(player.radius,Math.min(canvas.width-player.radius,player.x));
    player.y = Math.max(player.radius,Math.min(canvas.height-player.radius,player.y));

    // Skott
    player.bullets.forEach((b,i)=>{
        b.x += Math.cos(b.angle)*b.speed;
        b.y += Math.sin(b.angle)*b.speed;
        if(b.x<0||b.x>canvas.width||b.y<0||b.y>canvas.height) player.bullets.splice(i,1);
    });

    // Fiender
    enemies.forEach((e,i)=>{
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = Math.hypot(dx,dy);
        e.x += (dx/dist)*e.speed;
        e.y += (dy/dist)*e.speed;

        // Skott träff
        player.bullets.forEach((b,j)=>{
            if(Math.hypot(b.x-e.x,b.y-e.y)<e.radius){
                enemies.splice(i,1);
                player.bullets.splice(j,1);
                score += 10;
                hitSound.currentTime=0; hitSound.play();
            }
        });

        // Koll med spelare
        if(dist < e.radius+player.radius){
            enemies.splice(i,1);
            player.health -= 20;
            if(player.health<=0){
                gameOver=true; resetGame();
            }
        }
    });

    // Powerups
    powerups.forEach((p,i)=>{
        const d = Math.hypot(player.x-p.x,player.y-p.y);
        if(d<player.radius+p.radius){
            powerups.splice(i,1);
            if(p.type==='heal'){
                player.health = Math.min(player.maxHealth,player.health+30);
            } else if(p.type==='fast'){
                player.fireRate = 200;
                setTimeout(()=>player.fireRate=500,5000);
            } else if(p.type==='speed'){
                player.speedBoost = true;
                setTimeout(()=>player.speedBoost=false,5000);
            }
            powerupSound.currentTime=0; powerupSound.play();
        }
    });

    // Spawn fiender/powerups
    if(Date.now()-lastEnemySpawn > Math.max(500,2000-wave*100)){spawnEnemy(); lastEnemySpawn=Date.now();}
    if(Date.now()-lastPowerupSpawn>8000){spawnPowerup(); lastPowerupSpawn=Date.now();}

    // Wave progression
    if(enemies.length===0) wave++;

    // HUD
    document.getElementById('score').textContent="Score: "+score;
    document.getElementById('time').textContent="Tid: "+Math.floor(elapsedTime)+"s";
    document.getElementById('wave').textContent="Wave: "+wave;
    const healthPct = (player.health/player.maxHealth)*100;
    document.getElementById('healthInner').style.width = healthPct+"%";
}

// Draw
function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Spelare
    ctx.fillStyle=player.color;
    ctx.beginPath();
    ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);
    ctx.fill();
    // Ögon (för lite gubbe-känsla)
    ctx.fillStyle='white';
    ctx.beginPath();
    ctx.arc(player.x-7,player.y-5,4,0,Math.PI*2);
    ctx.arc(player.x+7,player.y-5,4,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle='black';
    ctx.beginPath();
    ctx.arc(player.x-7,player.y-5,2,0,Math.PI*2);
    ctx.arc(player.x+7,player.y-5,2,0,Math.PI*2);
    ctx.fill();

    // Skott
    ctx.fillStyle='yellow';
    player.bullets.forEach(b=>{
        ctx.beginPath();
        ctx.arc(b.x,b.y,5,0,Math.PI*2);
        ctx.fill();
    });

    // Fiender
    enemies.forEach(e=>{
        ctx.fillStyle=e.color;
        ctx.beginPath();
        ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);
        ctx.fill();
        ctx.fillStyle='black';
        ctx.beginPath();
        ctx.arc(e.x-3,e.y-3,3,0,Math.PI*2);
        ctx.arc(e.x+3,e.y-3,3,0,Math.PI*2);
        ctx.fill();
    });

    // Powerups
    powerups.forEach(p=>{
        ctx.fillStyle=p.type==='heal'?'lime':(p.type==='fast'?'cyan':'magenta');
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);
        ctx.fill();
    });
}

let lastTime=0;
function gameLoop(timestamp){
    const deltaTime=timestamp-lastTime;
    lastTime=timestamp;
    update(deltaTime);
    draw();
    requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
